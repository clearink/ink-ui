#!/usr/bin/env node
'use strict';

var commander = require('commander');
var fse = require('fs-extra');
var ora = require('ora');
var alias = require('@rollup/plugin-alias');
var babel = require('@rollup/plugin-babel');
var commonjs = require('@rollup/plugin-commonjs');
var resolve = require('@rollup/plugin-node-resolve');
var replace = require('@rollup/plugin-replace');
var terser = require('@rollup/plugin-terser');
var glob = require('fast-glob');
var path = require('node:path');
var rollup = require('rollup');
var constants = require('./constants.js');
var autoprefixer = require('autoprefixer');
var cssnano = require('cssnano');
var postcss = require('postcss');
var sass = require('sass');
var tsm = require('ts-morph');
var slash = require('slash');
var chalk = require('chalk');
var fastXmlParser = require('fast-xml-parser');
var svgo = require('svgo');

const isNullish = obj => obj == null;
const {
  isArray
} = Array;
function isObjectLike(obj) {
  return obj != null && typeof obj === 'object';
}

function toArray(candidate) {
  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (isNullish(candidate)) return [];
  if (isArray(candidate)) return candidate;
  return strict ? [] : [candidate];
}

function capitalize(str) {
  return `${str.charAt(0).toUpperCase()}${str.slice(1)}`;
}

const re$1 = new RegExp(`^${constants.constants.iconAttrNamePrefix}`);
function formatAttrName(attribute) {
  const name = attribute.replace(re$1, '').split('-').map((str, index) => {
    return index === 0 ? str : capitalize(str);
  }).join('');
  return name === 'class' ? 'className' : name;
}

const re = new RegExp(`^${constants.constants.iconAttrNamePrefix}`);
function buildIconNodes(json) {
  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'node';
  const isFormatNode = type === 'node';
  const init = isFormatNode ? [] : {};
  if (!isObjectLike(json)) return init;
  return Object.entries(json).reduce((res, _ref) => {
    let [key, val] = _ref;
    const isTag = !re.test(key);
    if (!isFormatNode && !isTag) {
      res[formatAttrName(key)] = val;
    } else if (isTag && isArray(res)) {
      toArray(val).forEach(node => {
        res.push({
          tag: key,
          attrs: buildIconNodes(node, 'attr'),
          children: buildIconNodes(node, 'node')
        });
      });
    }
    return res;
  }, init);
}
function buildJsxTags(nodes, level) {
  if (!Array.isArray(nodes)) return '';
  return nodes.reduce((res, node) => {
    const isTopSvg = level === 0 && node.tag === 'svg';
    const text = buildJsxTags(node.children, level + 1);
    const attrs = Object.entries(node.attrs).map(_ref2 => {
      let [k, v] = _ref2;
      return ` ${k}="${v}"`;
    }).join('');
    res += `<${node.tag}${isTopSvg ? ' {...props}' : attrs}>${text}</${node.tag}>`;
    return res;
  }, '');
}
function buildIconSource(options) {
  const {
    base64,
    filename,
    dirname,
    iconName,
    json
  } = options;
  const nodes = buildIconNodes(json);
  const rootAttrs = nodes[0].attrs;
  return `/* eslint-disable */
// @ts-nocheck
/* This file is automatically generated, please do not manually modify it */
import { withIcon } from "@icons/_shared/components"
import type { IconProps } from "@icons/types"
import { withDefaults } from "@icons/_shared/utils"

function ${iconName}(_props: IconProps) {
  ${Object.keys(rootAttrs).length ? `const props = withDefaults(_props, ${JSON.stringify(rootAttrs)})` : 'const props = _props'}
  return ${buildJsxTags(nodes, 0)}
}

/** ![${filename}](${base64}) */
export default withIcon(${iconName}, ${JSON.stringify({
    name: filename,
    theme: dirname
  })})
`;
}

function clean() {
  for (var _len = arguments.length, files = new Array(_len), _key = 0; _key < _len; _key++) {
    files[_key] = arguments[_key];
  }
  return Promise.all(files.map(file => fse.remove(file)));
}

function formatExternals(pkgJson) {
  const {
    dependencies = {},
    peerDependencies = {}
  } = pkgJson;
  return Object.keys(dependencies).concat(Object.keys(peerDependencies)).map(pkg => new RegExp(`^${pkg}`)).concat(/node_modules/);
}

function removeExtname(file) {
  return file.slice(0, -path.extname(file).length);
}

function formatIconName(file) {
  const basename = path.basename(file);
  const dirname = path.dirname(file);
  const capitalize = str => {
    return `${str.charAt(0).toUpperCase()}${str.slice(1)}`;
  };
  return removeExtname(basename).split(/-/g).concat(dirname).map(capitalize).join('');
}

async function getPkgJson() {
  return fse.readJson(constants.constants.resolveCwd('./package.json'));
}

const logger = {
  error: function (text) {
    let log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const str = chalk.hex('#e74c3c')(text);
    if (!log) return str;
    console.log(str);
  },
  info: function (text) {
    let log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const str = chalk.hex('#3498db')(text);
    if (!log) return str;
    console.log(str);
  },
  success: function (text) {
    let log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const str = chalk.hex('#2ecc71')(text);
    if (!log) return str;
    console.log(str);
  },
  warning: function (text) {
    let log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const str = chalk.hex('#f39c12')(text);
    if (!log) return str;
    console.log(str);
  }
};

function moduleMatches(pattern, value) {
  if (pattern instanceof RegExp) {
    return pattern.test(value);
  }
  if (pattern.length > value.length) return false;
  return pattern === value || value.startsWith(`${pattern}/`);
}

function optimizeIcon(source) {
  return svgo.optimize(source, {
    floatPrecision: 2,
    plugins: [{
      name: 'cleanupAttrs'
    }, {
      name: 'removeDoctype'
    }, {
      name: 'removeXMLProcInst'
    }, {
      name: 'removeXMLNS'
    }, {
      name: 'removeComments'
    }, {
      name: 'removeMetadata'
    }, {
      name: 'removeTitle'
    }, {
      name: 'removeDesc'
    }, {
      name: 'removeUselessDefs'
    }, {
      name: 'removeEditorsNSData'
    }, {
      name: 'removeEmptyAttrs'
    }, {
      name: 'removeHiddenElems'
    }, {
      name: 'removeEmptyText'
    }, {
      name: 'removeEmptyContainers'
    }, {
      name: 'removeViewBox'
    }, {
      name: 'cleanupEnableBackground'
    }, {
      name: 'convertStyleToAttrs'
    }, {
      name: 'convertColors'
    }, {
      name: 'convertPathData'
    }, {
      name: 'convertTransform'
    }, {
      name: 'removeUnknownsAndDefaults'
    }, {
      name: 'removeNonInheritableGroupAttrs'
    }, {
      name: 'removeUselessStrokeAndFill'
    }, {
      name: 'removeUnusedNS'
    }, {
      name: 'cleanupIds'
    }, {
      name: 'cleanupNumericValues'
    }, {
      name: 'moveElemsAttrsToGroup'
    }, {
      name: 'moveGroupAttrsToElems'
    }, {
      name: 'collapseGroups'
    }, {
      name: 'removeRasterImages'
    }, {
      name: 'mergePaths'
    }, {
      name: 'convertShapeToPath'
    }, {
      name: 'sortAttrs'
    }, {
      name: 'removeDimensions'
    }, {
      name: 'removeAttrs',
      params: {
        attrs: ['class', 'viewBox']
      }
    }]
  });
}

async function safeWrite(filepath, data) {
  await fse.ensureFile(filepath);
  return fse.writeFile(filepath, data, {
    encoding: 'utf-8'
  });
}

function toBase64(source) {
  const size = 50;
  const newSource = source.replace(/<svg(.*?)>/, `<svg$1 width="${size}" height="${size}" fill="#cacaca">`).replace(/\#333/g, '#1677ff').replace(/\#E6E6E6/ig, '#e6f4ff');
  return svgo.optimize(newSource, {
    datauri: 'base64'
  }).data;
}

async function buildCode$1() {
  const root = constants.constants.src;
  const options = {
    cwd: root,
    ignore: constants.constants.ignoreFiles
  };
  const entries = glob.glob.sync('**/*.ts{,x}', options).reduce((result, file) => {
    result[removeExtname(file)] = path.resolve(root, file);
    return result;
  }, {});
  const pkgJson = await getPkgJson();
  const externals = formatExternals(pkgJson);
  externals.push(/\.(css|scss|sass)$/);
  const plugins = [resolve({
    extensions: constants.constants.jsExtensions
  }), commonjs(), babel(constants.constants.babelOptions), alias({
    entries: constants.constants.compsAlias
  })];
  await Promise.all([rollup.rollup({
    external: externals,
    input: entries,
    logLevel: 'silent',
    plugins,
    treeshake: false
  }).then(async bundle => {
    return Promise.all([bundle.write({
      dir: constants.constants.esm,
      entryFileNames: '[name].mjs',
      format: 'esm',
      preserveModules: true,
      sourcemap: true
    }), bundle.write({
      dir: constants.constants.cjs,
      exports: 'named',
      format: 'cjs',
      preserveModules: true,
      sourcemap: true
    })]);
  }), rollup.rollup({
    external: externals,
    input: path.resolve(root, 'index.ts'),
    logLevel: 'silent',
    plugins: plugins.concat(replace(constants.constants.replaces))
  }).then(async bundle => {
    return Promise.all([bundle.write({
      dir: constants.constants.umd,
      entryFileNames: '[name].js',
      format: 'umd',
      name: pkgJson.name,
      sourcemap: true
    }), bundle.write({
      dir: constants.constants.umd,
      entryFileNames: '[name].min.js',
      format: 'umd',
      name: pkgJson.name,
      plugins: [terser()],
      sourcemap: true
    })]);
  })]);
}

function copyScssFiles() {
  const root = constants.constants.src;
  const options = {
    cwd: root,
    ignore: constants.constants.ignoreFiles
  };
  const promises = glob.sync('**/*.{sc,sa,c}ss', options).map(file => {
    const filepath = path.resolve(root, file);
    return Promise.all([fse.copy(filepath, constants.constants.resolveEsm(file)), fse.copy(filepath, constants.constants.resolveCjs(file))]);
  });
  return Promise.all(promises);
}
function compileScssFiles() {
  const root = constants.constants.src;
  const options = {
    cwd: root,
    ignore: constants.constants.ignoreFiles
  };
  const promises = glob.sync('**/style/index.{sc,sa,c}ss', options).map(async file => {
    const filename = removeExtname(file);
    const filepath = path.resolve(root, file);
    const res = await sass.compileAsync(filepath);
    return Promise.all([safeWrite(constants.constants.resolveEsm(`${filename}.css`), res.css), safeWrite(constants.constants.resolveCjs(`${filename}.css`), res.css)]);
  });
  return Promise.all(promises);
}
async function compileCompScssFiles() {
  const processor = postcss([autoprefixer(), cssnano({
    preset: 'default'
  })]);
  const filename = constants.constants.fullCssFilename;
  const filepath = constants.constants.resolveSrc('style/components.scss');
  const sassResult = await sass.compileAsync(filepath);
  const cssResult = await processor.process(sassResult.css, {
    from: filepath
  });
  return Promise.all([safeWrite(constants.constants.resolveUmd(`${filename}.css`), sassResult.css), safeWrite(constants.constants.resolveUmd(`${filename}.min.css`), cssResult.css)]);
}
function buildPluginImportFiles() {
  const project = new tsm.Project({
    compilerOptions: {
      allowJs: true
    },
    skipAddingFilesFromTsConfig: true
  });
  const root = constants.constants.src;
  const options = {
    cwd: root,
    ignore: constants.constants.ignoreFiles
  };
  const promises = glob.sync('**/style/index.ts{,x}', options).map(file => {
    const filename = removeExtname(file);
    const filepath = path.resolve(root, file);
    const sourceFile = project.addSourceFileAtPath(filepath);
    sourceFile.getImportDeclarations().forEach(node => {
      const text = node.getModuleSpecifierValue();
      const filename = removeExtname(text);
      node.setModuleSpecifier(`${filename}.css`);
    });
    const sourceText = sourceFile.getText();
    const targetDir = path.dirname(filename);
    return Promise.all([safeWrite(constants.constants.resolveEsm(targetDir, 'css.mjs'), sourceText), safeWrite(constants.constants.resolveCjs(targetDir, 'css.js'), sourceText)]);
  });
  return Promise.all(promises);
}
async function buildCss() {
  return Promise.all([copyScssFiles(), compileScssFiles(), compileCompScssFiles(), buildPluginImportFiles()]);
}

async function buildDts$1() {
  const project = new tsm.Project({
    compilerOptions: {
      allowJs: true,
      declaration: true,
      declarationDir: constants.constants.esm,
      emitDeclarationOnly: true
    },
    skipAddingFilesFromTsConfig: true
  });
  const pkgJson = await getPkgJson();
  const externals = formatExternals(pkgJson);
  const resolveAlias = (filepath, text) => {
    const isExternal = externals.find(e => moduleMatches(e, text));
    if (isExternal) return;
    const matched = constants.constants.compsAlias.find(e => moduleMatches(e.find, text));
    if (!matched) return;
    let rel = path.relative(path.dirname(filepath), matched.replacement);
    if (!rel.startsWith('.')) rel = `./${rel}`;
    const re = new RegExp(`^${matched.find}`);
    return slash(text.replace(re, rel));
  };
  const root = constants.constants.src;
  glob.sync('**/*.ts{,x}', {
    cwd: root,
    ignore: constants.constants.ignoreFiles
  }).map(file => project.addSourceFileAtPath(path.resolve(root, file))).forEach(sourceFile => {
    const filepath = sourceFile.getFilePath();
    sourceFile.getExportDeclarations().concat(sourceFile.getImportDeclarations()).forEach(node => {
      const text = node.getModuleSpecifierValue();
      if (!text) return;
      const newText = resolveAlias(filepath, text);
      if (newText) node.setModuleSpecifier(newText);
    });
  });
  await project.emit({
    emitOnlyDtsFiles: true
  });
  await Promise.all(glob.sync('**/*.d.ts', {
    cwd: constants.constants.esm
  }).map(file => {
    const filepath = path.resolve(constants.constants.esm, file);
    return fse.copy(filepath, constants.constants.resolveCjs(file));
  }));
}

async function build$2(options) {
  logger.info('|-----------------------------------|');
  logger.info('|                                   |');
  logger.info('|  starting build comps library...  |');
  logger.info('|                                   |');
  logger.info('|-----------------------------------|\n');
  {
    const spinner = ora(logger.info('clean dist and source files\n', false)).start();
    await clean(constants.constants.esm, constants.constants.cjs, constants.constants.umd, constants.constants.resolveSrc('_internal'));
    spinner.succeed(logger.success('clean dist and source files successfully !\n', false));
    spinner.clear();
  }
  {
    const spinner = ora(logger.info('copy source files to ink-ui\n', false)).start();
    await fse.copy(constants.constants.resolveUtils('src'), constants.constants.resolveSrc('_internal/utils'));
    await fse.copy(constants.constants.resolveTypes('src'), constants.constants.resolveSrc('_internal/types'));
    spinner.succeed(logger.success('copy source files successfully!\n', false));
    spinner.clear();
  }
  if (options.js) {
    const spinner = ora(logger.info('starting build code\n', false)).start();
    await buildCode$1();
    spinner.succeed(logger.success('build code successfully!\n', false));
    spinner.clear();
  }
  if (options.dts) {
    const spinner = ora(logger.info('starting build dts\n', false)).start();
    await buildDts$1();
    spinner.succeed(logger.success('build dts successfully!\n', false));
    spinner.clear();
  }
  if (options.css) {
    const spinner = ora(logger.info('starting build css\n', false)).start();
    await buildCss();
    spinner.succeed(logger.success('build css successfully!\n', false));
    spinner.clear();
  }
  {
    const spinner = ora(logger.info('clean copy files\n', false)).start();
    await clean(constants.constants.resolveSrc('_internal'));
    spinner.succeed(logger.success('clean copy files!\n', false));
    spinner.clear();
  }
  logger.success('build comps library successfully !');
}

async function buildCode() {
  const root = constants.constants.src;
  const options = {
    cwd: root,
    ignore: constants.constants.ignoreFiles
  };
  const entries = glob.sync('**/*.ts{,x}', options).slice(0, 1).reduce((result, file) => {
    result[removeExtname(file)] = path.resolve(root, file);
    return result;
  }, {});
  const pkgJson = await getPkgJson();
  const externals = formatExternals(pkgJson);
  const plugins = [resolve({
    extensions: constants.constants.jsExtensions
  }), commonjs(), babel(constants.constants.babelOptions), alias({
    entries: constants.constants.iconsAlias
  })];
  await Promise.all([rollup.rollup({
    external: externals,
    input: entries,
    logLevel: 'silent',
    plugins,
    treeshake: false
  }).then(async bundle => {
    return Promise.all([bundle.write({
      dir: constants.constants.esm,
      entryFileNames: '[name].mjs',
      format: 'esm',
      preserveModules: true,
      sourcemap: true
    }), bundle.write({
      dir: constants.constants.cjs,
      exports: 'named',
      format: 'cjs',
      preserveModules: true,
      sourcemap: true
    })]);
  }), rollup.rollup({
    external: externals,
    input: path.resolve(root, 'index.ts'),
    logLevel: 'silent',
    plugins: plugins.concat(replace(constants.constants.replaces))
  }).then(async bundle => {
    return Promise.all([bundle.write({
      dir: constants.constants.umd,
      entryFileNames: '[name].js',
      format: 'umd',
      name: pkgJson.name,
      sourcemap: true
    }), bundle.write({
      dir: constants.constants.umd,
      entryFileNames: '[name].min.js',
      format: 'umd',
      name: pkgJson.name,
      plugins: [terser()],
      sourcemap: true
    })]);
  })]);
}

async function buildDts() {
  const project = new tsm.Project({
    compilerOptions: {
      allowJs: true,
      declaration: true,
      declarationDir: constants.constants.esm,
      emitDeclarationOnly: true
    },
    skipAddingFilesFromTsConfig: true
  });
  const pkgJson = await getPkgJson();
  const externals = formatExternals(pkgJson);
  const resolveAlias = (filepath, text) => {
    const isExternal = externals.find(e => moduleMatches(e, text));
    if (isExternal) return;
    const matched = constants.constants.iconsAlias.find(e => moduleMatches(e.find, text));
    if (!matched) return;
    let rel = path.relative(path.dirname(filepath), matched.replacement);
    if (!rel.startsWith('.')) rel = `./${rel}`;
    const re = new RegExp(`^${matched.find}`);
    return slash(text.replace(re, rel));
  };
  const root = constants.constants.src;
  glob.sync('**/*.ts{,x}', {
    cwd: root,
    ignore: constants.constants.ignoreFiles
  }).map(file => project.addSourceFileAtPath(path.resolve(root, file))).forEach(sourceFile => {
    const filepath = sourceFile.getFilePath();
    sourceFile.getExportDeclarations().concat(sourceFile.getImportDeclarations()).forEach(node => {
      const text = node.getModuleSpecifierValue();
      if (!text) return;
      const newText = resolveAlias(filepath, text);
      if (newText) node.setModuleSpecifier(newText);
    });
  });
  await project.emit({
    emitOnlyDtsFiles: true
  });
  await Promise.all(glob.sync('**/*.d.ts', {
    cwd: constants.constants.esm
  }).map(file => {
    const filepath = constants.constants.resolveEsm(file);
    return fse.copy(filepath, constants.constants.resolveCjs(file));
  }));
}

async function genIcons() {
  const assets = constants.constants.resolveIcons('assets');
  const iconsDir = constants.constants.resolveIcons('src/icons');
  const options = {
    cwd: assets,
    ignore: constants.constants.ignoreFiles
  };
  const parser = new fastXmlParser.XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: constants.constants.iconAttrNamePrefix
  });
  const iconEntries = [];
  const promises = glob.glob.sync('**/*.svg', options).map(async file => {
    const iconName = formatIconName(file);
    const source = await fse.readFile(path.resolve(assets, file), {
      encoding: 'utf8'
    });
    iconEntries.push(`export { default as ${iconName} } from './${iconName}'`);
    const result = buildIconSource({
      base64: toBase64(source),
      filename: removeExtname(path.basename(file)),
      iconName,
      dirname: path.dirname(file),
      json: parser.parse(optimizeIcon(source).data)
    });
    return safeWrite(path.resolve(iconsDir, `${iconName}.tsx`), result);
  });
  await Promise.all(promises);
  const content = `/* eslint-disable */\n\n${iconEntries.join('\n')}`;
  await safeWrite(path.resolve(iconsDir, 'index.tsx'), content);
}

async function build$1(options) {
  logger.info('|-----------------------------------|');
  logger.info('|                                   |');
  logger.info('|  starting build icons library...  |');
  logger.info('|                                   |');
  logger.info('|-----------------------------------|\n');
  {
    const spinner = ora(logger.info('clean dist and source file\n', false));
    await clean(constants.constants.esm, constants.constants.cjs, constants.constants.umd, constants.constants.resolveSrc('_internal'), constants.constants.resolveSrc('icons'));
    spinner.succeed(logger.success('clean dist and source files successfully !\n', false));
    spinner.clear();
  }
  await genIcons();
  {
    const spinner = ora(logger.info('copy source files to ink-ui\n', false)).start();
    await fse.copy(constants.constants.resolveUtils('src'), constants.constants.resolveSrc('_internal/utils'));
    await fse.copy(constants.constants.resolveTypes('src'), constants.constants.resolveSrc('_internal/types'));
    spinner.succeed(logger.success('copy source files successfully!\n', false));
    spinner.clear();
  }
  if (options.js) {
    const spinner = ora(logger.info('starting build code\n', false)).start();
    await buildCode();
    spinner.succeed(logger.success('build code successfully!\n', false));
    spinner.clear();
  }
  if (options.dts) {
    const spinner = ora(logger.info('starting build dts\n', false)).start();
    await buildDts();
    spinner.succeed(logger.success('build dts successfully!\n', false));
    spinner.clear();
  }
  {
    const spinner = ora(logger.info('clean copy files\n', false)).start();
    await clean(constants.constants.resolveSrc('_internal'));
    spinner.succeed(logger.success('clean copy files!\n', false));
    spinner.clear();
  }
  logger.success('build icons library successfully !');
}

async function build(options) {
  console.log('build validator', options);
}

async function gen(comp) {
  logger.info(comp);
}

const program = new commander.Command().name('ink scripts').description('用于编译/打包 ink-ui 组件库的脚本文件').version('0.0.1');
program.command('build:comps').description('build comps library').option('--no-dts', 'don\'t generate dts files', true).option('--no-js', 'don\'t generate js files', true).option('--no-css', 'don\'t generate css files', true).action(build$2);
program.command('build:icons').description('build icon library').option('--no-dts', 'don\'t generate dts files', true).option('--no-js', 'don\'t generate js files', true).action(build$1);
program.command('build:validator').description('build form-validator library').option('--no-dts', 'don\'t generate dts files', true).option('--no-js', 'don\'t generate js files', true).action(build);
program.command('gen [name]').description('generate component templates').action(gen);
program.parse(process.argv);
